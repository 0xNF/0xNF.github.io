<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head><title>|
Swipr - Server</title><meta charset=utf-8><meta name=generator content="Hugo 0.109.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content><meta name=description content="Part 10 of the Swipr series. The last step in the odyssey of Swipr, where we describe the core of the Swipr Server, the swiping logic, calling our SwiprML model, and actually using LibSwipr."><link rel=stylesheet href=/scss/main.min.5794be192d21535bdd301561e043a96b6adbad2b5c08279deff459e4661c613f.css integrity="sha256-V5S+GS0hU1vdMBVh4EOpa2rbrStcCCed7/RZ5GYcYT8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://0xnf.github.io/posts/ml/swipr10/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Swipr - Server"><meta name=twitter:description content="Part 10 of the Swipr series. The last step in the odyssey of Swipr, where we describe the core of the Swipr Server, the swiping logic, calling our SwiprML model, and actually using LibSwipr."><meta property="og:title" content="Swipr - Server"><meta property="og:description" content="Part 10 of the Swipr series. The last step in the odyssey of Swipr, where we describe the core of the Swipr Server, the swiping logic, calling our SwiprML model, and actually using LibSwipr."><meta property="og:type" content="article"><meta property="og:url" content="https://0xnf.github.io/posts/ml/swipr10/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-12-13T17:01:51-08:00"><meta property="article:modified_time" content="2018-12-13T17:01:51-08:00"><meta property="og:see_also" content="https://0xnf.github.io/posts/ml/swipr01/"><meta property="og:see_also" content="https://0xnf.github.io/posts/ml/swipr02/"><meta property="og:see_also" content="https://0xnf.github.io/posts/ml/swipr03/"><meta property="og:see_also" content="https://0xnf.github.io/posts/ml/swipr04/"><meta property="og:see_also" content="https://0xnf.github.io/posts/ml/swipr05/"><meta property="og:see_also" content="https://0xnf.github.io/posts/ml/swipr06/"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Swipr - Server","headline":"Swipr - Server","alternativeHeadline":"","description":"
      Part 10 of the Swipr series. The last step in the odyssey of Swipr, where we describe the core of the Swipr Server, the swiping logic, calling our SwiprML model, and actually using LibSwipr.


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/0xnf.github.io\/posts\/ml\/swipr10\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":{"@type":"Person","name":""},"copyrightYear":"2018","dateCreated":"2018-12-13T17:01:51.00Z","datePublished":"2018-12-13T17:01:51.00Z","dateModified":"2018-12-13T17:01:51.00Z","publisher":{"@type":"Organization","name":null,"url":"https://0xnf.github.io/","logo":{"@type":"ImageObject","url":"https:\/\/0xnf.github.io\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/0xnf.github.io\/posts\/ml\/swipr10\/","wordCount":"1814","genre":["machine learning","fast.ai"],"keywords":["CNN","web scraping","data collection","architecture"]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/ alt="profile picture"><div class=sidebar__introduction-title><a href=/></a></div><div class=sidebar__introduction-description><p></p></div></div><ul class=sidebar__list></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Swipr - Server</h1><p>Recall our arch diagram from the two chapters ago:</p><p><img src=/ml/swipr/SwiprServerArch.png alt="Swipr Server Arch"></p><p>The Database Service is a collection of methods opening and closing SQLite connections and, while important, is really exceedingly boring and furthermore, unsurprising. As such, we&rsquo;ll leave it out of the discussion.</p><p>We&rsquo;ll also leave out building the Razor Pages and the views, dealing with identity, migrating our initial user tables with EF Core and other such minutiae of running an ASP.NET Core server.</p><p>We&rsquo;re going to keep our discussion to the Swipr Service and the two Queuing Services.</p><h1 id=server-configurations>Server Configurations</h1><p>To make sure our server is configurable without recompiling, we have the notion of a <code>ServerConfig</code>, which is a class that stores some relevant values for the server, read in at start-up from various environment variables:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ServerConfigs</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Location of the Swipr DB</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> DBConnectionString { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// How often to dequeue users</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> TimeSpan TimeoutCheck { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// How long a Tinder user will be timed out from running out of Likes</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> TimeSpan LikeTimeout { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>set</span>; } = TimeSpan.FromHours(<span style=color:#ae81ff>12</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Where to store tinder pictures</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> TinderPicturesDirectory { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Location of SwiprML python script</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> SwiprScript { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=services>Services</h1><h2 id=threadsafe-queue>Threadsafe Queue</h2><p>This was intended to be a more complicated class, but it turns out all we needed was a concurrent queue.</p><p>We use this ConcurrentQueue make sure that the Queue and Dequeue services are pushing and pulling from the same list and have the same view of that list.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ThreadSafe</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ConcurrentQueue&lt;SwiprConfig&gt; EnabledUserConfigs = <span style=color:#66d9ef>new</span> ConcurrentQueue&lt;SwiprConfig&gt;();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=config-queue-service>Config Queue Service</h2><p>Our first relevant service is the Queue service - this is a hosted service that will, on a timer defined by the ServerConfigs, query the database to get any eligible Swipr Configs - an eligible Swipr Config is defined as being a configuration that the user hasn&rsquo;t manually disabled, one that isn&rsquo;t presently timed out due to Tinder Likes running out, and one that currently has no Facebook or Tinder token errors associated with it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConfigQueueService</span> : IHostedService, IDisposable {
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [...]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Task StartAsync(CancellationToken cancellationToken) {
</span></span><span style=display:flex><span>            _logger.LogInformation(<span style=color:#e6db74>&#34;Launching Queue Service&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            _timer = <span style=color:#66d9ef>new</span> Timer(DoWork, <span style=color:#66d9ef>null</span>, TimeSpan.Zero,
</span></span><span style=display:flex><span>                Constants.ServerConfig.TimeoutCheck);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Task.CompletedTask;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This is the core method</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> DoWork(<span style=color:#66d9ef>object</span> state) {
</span></span><span style=display:flex><span>            _logger.LogInformation(<span style=color:#e6db74>&#34;Checking for eligible profiles to queue up...&#34;</span>);
</span></span><span style=display:flex><span>            IList&lt;SwiprConfig&gt; configs = <span style=color:#66d9ef>await</span> DatabaseService.GetEligibleConfigs();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>foreach</span> (SwiprConfig sc <span style=color:#66d9ef>in</span> configs) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (sc.SwiprEnabled) {
</span></span><span style=display:flex><span>                    ThreadSafe.EnabledUserConfigs.Enqueue(sc);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>        [...]</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=config-dequeue-service>Config Dequeue Service</h2><p>One of our more important classes is the Dequeue service, which pulls from the Concurrent Queue on the same timer as the QueueService.</p><p>We add a few extra fields and methods to this class in order to keep it from pulling from the queue while LibSwipr and SwiprML are going through a user&rsquo;s account, essentially adding a lock to it while it&rsquo;s in progress.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> StillGoing = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> CheckWorking(<span style=color:#66d9ef>object</span> state);
</span></span></code></pre></div><p>Instead of the timer tick calling the DoWork method directly, we have it call a method that checks to make sure a Dequeue isn&rsquo;t already in progress.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConfigDequeueService</span> : IHostedService, IDisposable {
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [...]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> StillGoing = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [...]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> CheckWorking(<span style=color:#66d9ef>object</span> state) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (!StillGoing) {
</span></span><span style=display:flex><span>            StillGoing = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            DoWork(state);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            _logger.LogInformation(<span style=color:#e6db74>&#34;Was called to do more dequeue, but a previous dequeue was stil in progress.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> DoWork(<span style=color:#66d9ef>object</span> state) {
</span></span><span style=display:flex><span>        _logger.LogInformation(<span style=color:#e6db74>&#34;Launching new Dequeue while loop&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> maxErrors = <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> errorCount = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (ThreadSafe.EnabledUserConfigs.Any()) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(!ThreadSafe.EnabledUserConfigs.TryDequeue(<span style=color:#66d9ef>out</span> SwiprConfig sc)) {
</span></span><span style=display:flex><span>                errorCount += <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(errorCount == maxErrors) {
</span></span><span style=display:flex><span>                    _logger.LogCritical(<span style=color:#e6db74>$&#34;EnabledUserConfigs dequeue failed {errorCount} times, this run of the dequeue service will be terminated.&#34;</span>);
</span></span><span style=display:flex><span>                    StillGoing = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                _logger.LogCritical(<span style=color:#e6db74>$&#34;EnabledUserConfigs reports that it is not empty, but failed to dequeue a SwiprConfig. This is attempt number {errorCount}&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// check that the sc is still valid</span>
</span></span><span style=display:flex><span>                SwiprConfigStatus scs = <span style=color:#66d9ef>await</span> DatabaseService.CheckSwiprConfigStillValid(sc.UserId);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (!(scs.ConfigIsValid)) {
</span></span><span style=display:flex><span>                    _logger.LogInformation(<span style=color:#e6db74>$&#34;User {sc.UserId} disabled their Swipr config between enqueue time and dequeue time. Passing on execution for this config.&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>bool</span> success = <span style=color:#66d9ef>await</span> SwiprService.DoSwipr(sc);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (!success) {
</span></span><span style=display:flex><span>                            _logger.LogWarning(<span style=color:#e6db74>$&#34;Failed to complete swipr task for user {sc.UserId}&#34;</span>);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>                            _logger.LogInformation(<span style=color:#e6db74>$&#34;Successfully finished Swiping for user {sc.UserId}&#34;</span>);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>catch</span>(SwiprException se) {
</span></span><span style=display:flex><span>                        _logger.LogCritical(se.Message);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>catch</span>(Exception e) {
</span></span><span style=display:flex><span>                        _logger.LogCritical(e.Message);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        _logger.LogInformation(<span style=color:#e6db74>&#34;Finished dequeuing this batch of Swipr configs&#34;</span>);
</span></span><span style=display:flex><span>        StillGoing = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [...]</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To keep us from getting stuck on one user too much, we keep track of the various errors that my occur and abandon this SwiprUser if they fail, for whatever reason, more than 10 times.</p><p>We do this because Swipr is essentially single-threaded and can only handle one Swipr user at a time, so we want to give the current Swipr user enough of a fair chance at getting their chance as possible, but we also don&rsquo;t want to hold up the whole queue by waiting forever on this one user. These problems would be diminished if Swipr could query for multiple Tinder users at once, and if SwiprML was a bit quicker.</p><p>One we have our eligible Swipr configuration, we make the critical call out to <code>SwiprService.DoSwipr()</code>, which will do the hard work of combining everything we&rsquo;ve done so far.</p><h1 id=swipr-service>Swipr Service</h1><h2 id=doswipr>DoSwipr()</h2><p>We start the method by requesting the tokens of the current Swipr User - remember that a Tinder token has a limited duration, so we&rsquo;ll need everything stored by the user to sign in again and get another token.</p><p>We also set up variables for break conditions and statistics. When the total number of <code>ThisSessionLikes</code> and <code>ThisSessionPasses</code> reaches our <code>SessionLimit</code>, we stop working on this user and move on to a new one.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// Break condition variables</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> success = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ThisSessionLikes = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ThisSessionPasses = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ThisSessionErrors = <span style=color:#ae81ff>0</span>;
</span></span></code></pre></div><p>The first thing we do is check if the token we pulled from the Database is valid, and if not, run the sign-in process again to get a new one. The <code>Refresh</code> methods handles saving this new information back to the Database.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// Checking status of tokens</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(!<span style=color:#66d9ef>await</span> Refresh(sc.UserId, at)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> SwiprFacebookTokenException();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we fail to sign in, we write the error to the <code>SwiprErrors</code> table and try with a different user. An error here requires that the user re-do the entire sign in process. They are disabled on Swipr until they fix this. Usually this is because we triggered Facebook&rsquo;s security and got their account locked out.</p><p>If we have a working token, we get whatever potential matches that Tinder has queued up for us via a call to LibSwipr.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// Getting users</span>
</span></span><span style=display:flex><span>IList&lt;User&gt; matches = <span style=color:#66d9ef>new</span> List&lt;User&gt;();
</span></span><span style=display:flex><span>matches = <span style=color:#66d9ef>await</span> TinderAPI.GetMatches(at.TinderAuthenticationToken);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (!matches.Any()) {
</span></span><span style=display:flex><span>    cont = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    success = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Once we have matches, we do a bunch of work for each Tinder User we got, including making sure it has entries in both our Database, and our filesystem so we can store pictures. Once we&rsquo;ve ensured a user has been accounted for, we call out our profile evaluator, which in addition to containing the swipe logic and the call to SwiprML, also contains the callback to Tinder.</p><p>We switch on the result of our evaluator and record that result.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// Evaluating users</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[...]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>foreach</span>(User u <span style=color:#66d9ef>in</span> matches){
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [...]</span>
</span></span><span style=display:flex><span>    EvaluationResult er = <span style=color:#66d9ef>await</span> EvaluateProfile(sc, u);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (er.ActionTaken) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> SwipeAction.NA:
</span></span><span style=display:flex><span>            logger.Error(<span style=color:#e6db74>&#34;Swipr couldn&#39;t classify this profile - an error ocurred&#34;</span>);
</span></span><span style=display:flex><span>            ThisSessionErrors += <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> SwipeAction.LIKED:
</span></span><span style=display:flex><span>            logger.Info(<span style=color:#e6db74>$&#34;Liked Tinder User {u.Id} for Swipr User {sc.UserId} because: {er.Reason}&#34;</span>);
</span></span><span style=display:flex><span>            ThisSessionLikes += <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> SwipeAction.PASSED:
</span></span><span style=display:flex><span>            ThisSessionPasses += <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            logger.Info(<span style=color:#e6db74>$&#34;Passed on Tinder User {u.Id} for Swipr User {sc.UserId} because: {er.Reason}&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> SwipeAction.SUPERLIKED:
</span></span><span style=display:flex><span>            ThisSessionLikes += <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            logger.Info(<span style=color:#e6db74>$&#34;Super-Liked Tinder User {u.Id} for Swipr User {sc.UserId} because: {er.Reason}&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>            logger.Error(<span style=color:#e6db74>&#34;CRITICAL: Some uncategorized error ocurred. This should never happen.&#34;</span>);
</span></span><span style=display:flex><span>            ThisSessionErrors += <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// TODO this is an error condition that should never happen.</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [...]</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=evaluateprofile>EvaluateProfile()</h2><p>There is some nuance that is worth spending some time on in this method. Unlike Lyricall, we&rsquo;re not allowing infinite nesting and arbitrary ordering of the conditions to be met for a profile to be passed or failed upon, so the order as listed herein is important.</p><p>The order goes like this:</p><ol><li>Does this User have any pictures?<ul><li>if not, fail</li></ul></li><li>Does our Swipr User have any Likes left to use?<ul><li>Has user enabled the Out-Of-Likes SuperLike strategy?<ul><li>if so, SuperLike if we have any left</li></ul></li><li>fail otherwise</li></ul></li><li>Are we blindly accepting all matches?<ul><li>if so, like and move on</li></ul></li><li>Are Ages enabled, and does the Tinder User fall within the range specified?<ul><li>if not, fail</li></ul></li><li>Is Distance enabled and does the Tinder User fall within the range specified?<ul><li>if not fail</li></ul></li><li>Is bio enabled, and if so does the user have an empty bio?<ul><li>if so, fail</li><li>otherwise, check for Banned bio keywords</li><li>then, if SuperLike strategies has the WordMatch strat, check if bio has any SuperLike word.<ul><li>if so, superlike and move on</li></ul></li><li>finally, check if Bio contains an auto-like keyword<ul><li>if so, like and move on</li></ul></li></ul></li><li>Finally, call out to SwiprML</li></ol><p>The last step has some nuance as well.</p><p>To make this easy on us, we have decided that as long as at least one picture from the given user&rsquo;s profile can pass a minimum confidence check from SwiprML, we consider the entire profile a pass. We considered having some percentage of available pictures be the deciding criterion, but in the end, a single passable picture is good enough for now.</p><p>There&rsquo;s some additional complicating logic within this particular step but it amount to the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>SwiprMLResult smlr = <span style=color:#66d9ef>await</span> SendToSwiprML(tinderUserId, swiprUserId, pictureLocation);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (smlr.Crashed) {
</span></span><span style=display:flex><span>    perPic.Add(<span style=color:#66d9ef>new</span> EvaluationResult(SwipeAction.NA, <span style=color:#e6db74>&#34;AI Crashed&#34;</span>, WasAMatch, picfname));
</span></span><span style=display:flex><span>} 
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (smlr.ConfidenceLike &lt; swiprConfig.MinimumConfidence) {
</span></span><span style=display:flex><span>    perPic.Add(<span style=color:#66d9ef>new</span> EvaluationResult(SwipeAction.PASSED, <span style=color:#e6db74>&#34;AI Says Pass&#34;</span>, WasAMatch, picfname));
</span></span><span style=display:flex><span>} 
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We immediately return the pass result</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> TinderAPI.LikeUser(u.Id);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> EvaluationResult(SwipeAction.LIKED, <span style=color:#e6db74>&#34;AI Says OK&#34;</span>, WasAMatch, picfname);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Where <code>SendToSwiprML()</code> downloads the picture and makes a call to the our SwiprServiceScript from a few parts ago to get a prediction. We also make sure to note if SwiprML crashed, which, while uncommon, is not unheard of. We take notes when it does.</p><p>Like said earlier, the moment any part of this big function comes to a conclusion on what action to take with respect to the supplied tinder user, we make the call to Tinder ourselves immediately and return back to looping through other users.</p><h1 id=summary>Summary</h1><p>There&rsquo;s a bit more to the SwiprServer than just what&rsquo;s shown. We support displaying results of the server to see who was passed over and why, we support changing your SwiprConfig from a web based UI, seeing errors in your profile on your settings page, etc.</p><p>You can see the full extent the implementation over at <a href=https://0xnf.github.com/swiprserver>https://0xnf.github.com/swiprserver</a>.</p><h1 id=moving-on>Moving On</h1><p>That concludes our tour of Swipr, where we wrap up another attempt to learn and utilize machine learning.</p><h3>Posts in this series</h3><ul><li><a href=/posts/ml/swipr10/>Swipr - Server</a></li><li><a href=/posts/ml/swipr09/>Swipr - Datastore</a></li><li><a href=/posts/ml/swipr08/>Swipr - LibSwipr</a></li><li><a href=/posts/ml/swipr07/>Swipr - Swipr Script Service</a></li><li><a href=/posts/ml/swipr06/>Swipr - Fast.ai and CNNs</a></li><li><a href=/posts/ml/swipr05/>Swipr - Data Cleaning</a></li><li><a href=/posts/ml/swipr04/>Swipr - Data Collection (Part 2 of 2)</a></li><li><a href=/posts/ml/swipr03/>Swipr - Data Collection (Part 1 of 2)</a></li><li><a href=/posts/ml/swipr02/>Swipr - Scope</a></li><li><a href=/posts/ml/swipr01/>Swipr - Overview</a></li></ul></div><div class=post__footer><span><a class=category href=/categories/machine-learning/>machine learning</a><a class=category href=/categories/fast%2eai/>fast.ai</a></span>
<span><a class=tag href=/tags/cnn/>CNN</a><a class=tag href=/tags/web-scraping/>web scraping</a><a class=tag href=/tags/data-collection/>data collection</a><a class=tag href=/tags/architecture/>architecture</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>