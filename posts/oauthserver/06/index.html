<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head><title>|
Implement an OAuth 2.0 Server (Part 06)</title><meta charset=utf-8><meta name=generator content="Hugo 0.109.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content><meta name=description content="We'll spend some time creating setting up the OAuth Client views, which let a user register and edit an OAuth Client. This section deals with the ViewModels and Controllers."><link rel=stylesheet href=/scss/main.min.5794be192d21535bdd301561e043a96b6adbad2b5c08279deff459e4661c613f.css integrity="sha256-V5S+GS0hU1vdMBVh4EOpa2rbrStcCCed7/RZ5GYcYT8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://0xnf.github.io/posts/oauthserver/06/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Implement an OAuth 2.0 Server (Part 06)"><meta name=twitter:description content="We'll spend some time creating setting up the OAuth Client views, which let a user register and edit an OAuth Client. This section deals with the ViewModels and Controllers."><meta property="og:title" content="Implement an OAuth 2.0 Server (Part 06)"><meta property="og:description" content="We'll spend some time creating setting up the OAuth Client views, which let a user register and edit an OAuth Client. This section deals with the ViewModels and Controllers."><meta property="og:type" content="article"><meta property="og:url" content="https://0xnf.github.io/posts/oauthserver/06/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-06T16:16:01-07:00"><meta property="article:modified_time" content="2018-06-06T16:16:01-07:00"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/01/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/02/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/03/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/04/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/05/"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Implement an OAuth 2.0 Server (Part 06)","headline":"Implement an OAuth 2.0 Server (Part 06)","alternativeHeadline":"","description":"
      We\u0027ll spend some time creating setting up the OAuth Client views, which let a user register and edit an OAuth Client. This section deals with the ViewModels and Controllers.


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/0xnf.github.io\/posts\/oauthserver\/06\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":{"@type":"Person","name":""},"copyrightYear":"2018","dateCreated":"2018-06-06T16:16:01.00Z","datePublished":"2018-06-06T16:16:01.00Z","dateModified":"2018-06-06T16:16:01.00Z","publisher":{"@type":"Organization","name":null,"url":"https://0xnf.github.io/","logo":{"@type":"ImageObject","url":"https:\/\/0xnf.github.io\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/0xnf.github.io\/posts\/oauthserver\/06\/","wordCount":"1704","genre":["Security","Identity","Authentication","Authorization"],"keywords":["OAuth2.0","OpenIdConnect","Tutorial","CSharp",".NET Core"]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/ alt="profile picture"><div class=sidebar__introduction-title><a href=/></a></div><div class=sidebar__introduction-description><p></p></div></div><ul class=sidebar__list></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Implement an OAuth 2.0 Server (Part 06)</h1><p>Welcome to the sixth part of a series of posts where we will implement an OAuth 2 Server using <a href=https://github.com/aspnet-contrib/AspNet.Security.OpenIdConnect.Server>AspNet.Security.OpenIdConnectServer</a>.</p><h1 id=oauth-client-crud---controller-and-viewmodels>OAuth Client CRUD - Controller and ViewModels</h1><p>This is the first part of adding our OAuth Client management pages. We&rsquo;ll set up the controller and the viewmodel here. <a href=/posts/oauthserver/part07>In next part</a>, we&rsquo;ll add the html views.</p><h2 id=view-models>View Models</h2><p>ViewModels are, at least in the context of <code>ASP.NET</code> (as opposed to UWP where the MVVM pattern changes what it means slightly), is a way of firewalling our models from our views. Our models may have fields we don&rsquo;t want to expose all the time. This may get in the way of automatically validating fields, it may lead to extra hidden form fields in our views, and it can generally be a pain to deal with.</p><p>To get around that, we create some <code>ViewModels</code>, which only contain the data we wish to send to and from our views. In our case, we&rsquo;re going to be using them to avoid sending over the <code>ClientSecret</code> and <code>Owner</code> all the time.</p><p>Under the <code>Models/</code> folder, create a new folder called <code>OAuthClientsViewModels/</code>.</p><h3 id=create-view-model>Create View Model</h3><p>The first class we&rsquo;re going to create under <code>Models/OAuthClientsViewModels/</code> is <code>CreateClientViewModel</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CreateClientViewModel</span> {
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [Required]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [MinLength(2)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [MaxLength(100)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> ClientName { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [Required]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [MinLength(1)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [MaxLength(500)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> ClientDescription { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Our Create page only requires the user to supply a <code>name</code> and a <code>description</code>. A complete <code>OAuthClient</code> has other fields like <code>ClientId</code> and <code>ClientSecret</code>, but we&rsquo;d be inviting disaster if we let the user supply their own ids. We&rsquo;ll be generating those values on the server, without user input.</p><p>We specify attributes on the fields so that the automatic validation knows what kinds of errors to provide back to the user.</p><h3 id=edit-view-model>Edit View Model</h3><p>We&rsquo;ll send over many of the same fields that make up a regular client, but the only thing we expect back is the client description, which may or may not have changed. The user is allowed to view but not edit the other fields.</p><p>We set the RedirectURIs to be a <code>string[]</code> because we&rsquo;ll be using Razor Page binding techniques to automatically group submitted urls together into one field.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EditClientViewModel</span> {
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [Required]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [MinLength(1)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [MaxLength(500)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> ClientDescription { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> ClientName { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> ClientId { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> ClientSecret { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span>[] RedirectUris { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; } = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>string</span>[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We mark some of these as being <code>internal set</code> so that the validation doesn&rsquo;t try to check them. We&rsquo;ll send the client secret over too, so that a user can regenerate the secret if they need to.</p><h2 id=controller>Controller</h2><p>Next is to add a new controller. Unlike the public API controller, we&rsquo;ll be generating this one automatically.</p><p>Right click on <code>Controllers</code>, select <code>Add</code>, and click <code>Controller</code>.
Choose <code>MVC Controller with views, using Entity Framework</code></p><p><img src=/oauthserver/part06/newcontroller_withviews.png alt="New Controller"></p><p>Fill out the <code>Model class</code> with the <code>OAuthClient</code>,
Fill out the <code>Data conext class</code> with <code>ApplicationDbContext</code>,<br>and leave the rest as the defaults.</p><p><img src=/oauthserver/part06/newcontroller_details.png alt="new defaults"></p><p>This has the benefit of automatically generating all the necessary views for us. We just need to make a few tweaks to them.</p><h3 id=authorization>Authorization</h3><p>First off we need to add an <code>[Authorize]</code> attribute to the controller. Unauthorized visitors, aka, users that are not signed in, will be redirected to the home page.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-csharp data-lang=csharp><span style=display:flex;background-color:#3c3d38><span><span style=color:#a6e22e>[Authorize]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OAuthClientsController</span> : Controller
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ApplicationDbContext _context;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> OAuthClientsController(ApplicationDbContext context)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _context = context;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=user-manager>User Manager</h3><p>We&rsquo;ll need to manipulate the users who access these pages, so we need to inject <code>UserManager</code> into the constructor</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[Authorize]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OAuthClientsController</span> : Controller {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ApplicationDbContext _context;
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> UserManager&lt;ApplicationUser&gt; _userManager;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>public</span> OAuthClientsController(ApplicationDbContext context, UserManager&lt;ApplicationUser&gt; userManager) {
</span></span><span style=display:flex><span>        _context = context;
</span></span><span style=display:flex;background-color:#3c3d38><span>        _userManager = userManager;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=index>Index</h3><p>The Index should only return the clients for which the current user is the <code>Owner</code>.</p><p>This also introduces the <code>Entity Framework</code> concept of <code>Includes</code>.</p><p>If you&rsquo;re not familiar with Entity Framework Core, models with additional models on them, like our <code>Owner</code> on the <code>OAuthClient</code> are not populated by default when querying. This is to save on bandwidth and I/O costs, but it can be a surprise if you&rsquo;re not expecting a sudden Null Pointer. The solution is to call <code>.Include()</code> on the <code>DbSet</code> with the field we need. In this case, the method chain looks like <code>_context.ClientApplications.Include(x => x.Owner)...</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// GET: OAuthClients</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; Index() {
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>string</span> uid = _userManager.GetUserId(<span style=color:#66d9ef>this</span>.User);
</span></span><span style=display:flex;background-color:#3c3d38><span>    <span style=color:#66d9ef>return</span> View(<span style=color:#66d9ef>await</span> _context.ClientApplications.Include(x =&gt; x.Owner).Where(x =&gt; x.Owner.Id == uid).ToListAsync());
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=details>Details</h3><p>Delete the <code>Details(string id)</code> method - we won&rsquo;t be using it, because we&rsquo;re going to combine it with our <code>Edit</code> page.</p><h3 id=post-create>POST Create</h3><p>We can leave the GET Create method alone and move on to the POST Create method.</p><p>This method gets changed quite a bit - we swap out the <code>OAuthClient</code> for our <code>CreateClientViewModel</code>, change what fields we&rsquo;re listening to in the <code>[Bind]</code> parameter, and we create a new <code>OAuthClient</code> with generated values for <code>ClientId</code> and <code>ClientSecret</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// POST: OAuthClients/Create</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// To protect from overposting attacks, please enable the specific properties you want to bind to, for </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// more details see http://go.microsoft.com/fwlink/?LinkId=317598.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[HttpPost]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[ValidateAntiForgeryToken]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; Create([Bind(<span style=color:#e6db74>&#34;ClientName,ClientDescription&#34;</span>)] CreateClientViewModel vm)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (ModelState.IsValid)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ApplicationUser owner = <span style=color:#66d9ef>await</span> _userManager.GetUserAsync(<span style=color:#66d9ef>this</span>.User);
</span></span><span style=display:flex><span>        OAuthClient client = <span style=color:#66d9ef>new</span> OAuthClient() {
</span></span><span style=display:flex><span>            ClientDescription = vm.ClientDescription,
</span></span><span style=display:flex><span>            ClientName = vm.ClientName,
</span></span><span style=display:flex><span>            ClientId = Guid.NewGuid().ToString(),
</span></span><span style=display:flex><span>            ClientSecret = Guid.NewGuid().ToString(),
</span></span><span style=display:flex><span>            Owner = owner,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        _context.Add(client);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> _context.SaveChangesAsync();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> RedirectToAction(nameof(Index));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> View(vm);
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=get-edit>GET Edit</h3><p>This is the <code>GET</code> version of <code>EDIT</code>. POST will get its own special treatment.</p><p>We&rsquo;ll be using the <code>EditClientViewModel</code> from before, along with our standard checks for ownership.
To match the viewmodel&rsquo;s fields, we transform any existing <code>RedirectURIs</code> to their string form, then to an array with LINQ.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// GET: OAuthClients/Edit/5</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; Edit(<span style=color:#66d9ef>string</span> id)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (String.IsNullOrEmpty(id)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NotFound();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> uid = _userManager.GetUserId(<span style=color:#66d9ef>this</span>.User);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> oAuthClient = <span style=color:#66d9ef>await</span> _context.ClientApplications.Include(x =&gt; x.Owner).Include(x=&gt;x.RedirectURIs)
</span></span><span style=display:flex><span>        .SingleOrDefaultAsync(m =&gt; m.ClientId == id &amp;&amp; m.Owner.Id == uid);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (oAuthClient == <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NotFound();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    EditClientViewModel vm = <span style=color:#66d9ef>new</span> EditClientViewModel() {
</span></span><span style=display:flex><span>        ClientName = oAuthClient.ClientName,
</span></span><span style=display:flex><span>        ClientDescription = oAuthClient.ClientDescription,
</span></span><span style=display:flex><span>        ClientId = oAuthClient.ClientId,
</span></span><span style=display:flex><span>        ClientSecret = oAuthClient.ClientSecret,
</span></span><span style=display:flex><span>        RedirectUris = oAuthClient.RedirectURIs.Select(x =&gt; x.URI).ToArray()
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> View(vm);
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=post-edit>POST EDIT</h3><p>The method is large but not as big as it looks - it contains a nested internal method. It could be extracted out, but it only exists to deal with one specific scenario while editing a client, so it&rsquo;s been stuffed inside this one.</p><p>We&rsquo;ve edited the Bind parameters to be just the fields that a user can actually edit - the <code>Client Description</code> and the <code>RedirectUris</code>.</p><p>After our standard ownership checks, we make sure to include the <code>RedirectURIs</code> while fetching from the context, because we need to perform some operations on the ones that already exist.</p><p>The meat of the method is under <code>CheckAndMark</code>, which just adds re-submitted URIs, creates ones that didn&rsquo;t exist before, and then uses LINQ&rsquo;s <code>Except</code> and <code>Select</code> to mark any deleted URIs as <code>EntityState.Deleted</code> for Entity Framework.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// POST: OAuthClients/Edit/5</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// To protect from overposting attacks, please enable the specific properties you want to bind to, for </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// more details see http://go.microsoft.com/fwlink/?LinkId=317598.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[HttpPost]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[ValidateAntiForgeryToken]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; Edit(<span style=color:#66d9ef>string</span> id, [Bind(<span style=color:#e6db74>&#34;ClientDescription&#34;</span>, <span style=color:#e6db74>&#34;RedirectUris&#34;</span>)] EditClientViewModel vm)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> uid = _userManager.GetUserId(<span style=color:#66d9ef>this</span>.User);
</span></span><span style=display:flex><span>    OAuthClient client = <span style=color:#66d9ef>await</span> _context.ClientApplications.Include(x =&gt; x.Owner).Include(x=&gt;x.RedirectURIs).Where(x =&gt; x.ClientId == id &amp;&amp; x.Owner.Id == uid).FirstOrDefaultAsync();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (client == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NotFound();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (ModelState.IsValid)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            List&lt;RedirectURI&gt; originalUris = client.RedirectURIs;
</span></span><span style=display:flex><span>            CheckAndMark(originalUris, vm.RedirectUris);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            client.ClientDescription = vm.ClientDescription;
</span></span><span style=display:flex><span>            _context.Update(client);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>await</span> _context.SaveChangesAsync();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>catch</span> (DbUpdateConcurrencyException)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (!OAuthClientExists(vm.ClientId))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> NotFound();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> RedirectToAction(nameof(Index));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> View(vm);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> CheckAndMark(List&lt;RedirectURI&gt; originals, IEnumerable&lt;<span style=color:#66d9ef>string</span>&gt; submitted) {
</span></span><span style=display:flex><span>        List&lt;RedirectURI&gt; newList = <span style=color:#66d9ef>new</span> List&lt;RedirectURI&gt;(); 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span>(<span style=color:#66d9ef>string</span> s <span style=color:#66d9ef>in</span> submitted) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (String.IsNullOrWhiteSpace(s)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            RedirectURI fromOld = originals.FirstOrDefault(x =&gt; x.URI == s);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(fromOld == <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// this &#39;s&#39; is new.</span>
</span></span><span style=display:flex><span>                RedirectURI rdi = <span style=color:#66d9ef>new</span> RedirectURI() { OAuthClient = client, OAuthClientId = client.ClientId, URI = s };
</span></span><span style=display:flex><span>                newList.Add(rdi);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// this &#39;s&#39; was re-submitted</span>
</span></span><span style=display:flex><span>                newList.Add(fromOld);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Marking deleted Redirect URIs for Deletion.</span>
</span></span><span style=display:flex><span>        originals.Except(newList).Select(x =&gt; _context.Entry(x).State = EntityState.Deleted);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Assign the new list back to the client</span>
</span></span><span style=display:flex><span>        client.RedirectURIs = newList;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=get-delete>Get Delete</h3><p>Delete the <code>Delete (string id)</code> method. Like our <code>Details</code> method, we&rsquo;re going to combine it with <code>Edit</code>.</p><p>This is the <code>GET</code> version of <code>DELETE</code>. Like Edit, POST will get its own special treatment.</p><h3 id=post-delete>POST Delete</h3><p>Attempting to post a delete forces a client/user check.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// POST: OAuthClients/Delete/5</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[HttpPost, ActionName(&#34;Delete&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[ValidateAntiForgeryToken]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; DeleteConfirmed(<span style=color:#66d9ef>string</span> id)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (String.IsNullOrEmpty(id)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NotFound();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> uid = _userManager.GetUserId(<span style=color:#66d9ef>this</span>.User);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> oAuthClient = <span style=color:#66d9ef>await</span> _context.ClientApplications.Include(x =&gt; x.Owner)
</span></span><span style=display:flex><span>        .SingleOrDefaultAsync(m =&gt; m.ClientId == id &amp;&amp; m.Owner.Id == uid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(oAuthClient == <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NotFound();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _context.ClientApplications.Remove(oAuthClient);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> _context.SaveChangesAsync();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> RedirectToAction(nameof(Index));
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h3 id=reset-client-secret>Reset Client Secret</h3><p>This is a custom method we&rsquo;re going to add - it did not come generated in the controller.</p><p>We supply this method so a user can regenerate their <code>client secret</code> in the event they mistakenly check it into source control, or if it&rsquo;s leaked by any other means. The implications of this are that when a user&rsquo;s authentication tokens come up for renewal, they&rsquo;ll need to restart the entire process. If the client is on a phone, or is otherwise an installed application as opposed to a web app, the user will need to download a new build of the application containing the new secret.</p><p>As a side note, this is why iOS and Android apps seem to update so frequently without adding anything in their release notes - they&rsquo;re cycling their application keys according to some schedule as a security precaution.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// POST: OAuthClients/ResetSecret/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[HttpPost, ActionName(&#34;ResetSecret&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[ValidateAntiForgeryToken]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; ResetClientSecret(<span style=color:#66d9ef>string</span> id) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> uid = _userManager.GetUserId(<span style=color:#66d9ef>this</span>.User);
</span></span><span style=display:flex><span>    OAuthClient client = <span style=color:#66d9ef>await</span> _context.ClientApplications.Include(x =&gt; x.Owner).Include(x =&gt; x.RedirectURIs).Where(x =&gt; x.ClientId == id &amp;&amp; x.Owner.Id == uid).FirstOrDefaultAsync();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (client == <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NotFound();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        client.ClientSecret = Guid.NewGuid().ToString();
</span></span><span style=display:flex><span>        _context.Update(client);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> _context.SaveChangesAsync();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span> (DbUpdateConcurrencyException) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (!OAuthClientExists(client.ClientId)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> NotFound();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> RedirectToAction(id, <span style=color:#e6db74>&#34;OAuthClients/Edit&#34;</span>);
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h1 id=moving-on>Moving On</h1><p>The demo of this project to this point can be found <a href=https://github.com/0xNF/OAuthTutorial/tree/06-ClientCRUDVMs>here on GitHub</a>.</p><p>In the next section we&rsquo;ll deal with the second half of this unit and modify the generated Views.
<a href=/posts/oauthserver/07>Next</a></p><h3>Posts in this series</h3><ul><li><a href=/posts/oauthserver/19/>Implement an OAuth 2.0 Server (Part 19)</a></li><li><a href=/posts/oauthserver/18/>Implement an OAuth 2.0 Server (Part 18)</a></li><li><a href=/posts/oauthserver/17/>Implement an OAuth 2.0 Server (Part 17)</a></li><li><a href=/posts/oauthserver/16/>Implement an OAuth 2.0 Server (Part 16)</a></li><li><a href=/posts/oauthserver/15/>Implement an OAuth 2.0 Server (Part 15)</a></li><li><a href=/posts/oauthserver/14/>Implement an OAuth 2.0 Server (Part 14)</a></li><li><a href=/posts/oauthserver/13/>Implement an OAuth 2.0 Server (Part 13)</a></li><li><a href=/posts/oauthserver/12/>Implement an OAuth 2.0 Server (Part 12)</a></li><li><a href=/posts/oauthserver/11/>Implement an OAuth 2.0 Server (Part 11)</a></li><li><a href=/posts/oauthserver/10/>Implement an OAuth 2.0 Server (Part 10)</a></li><li><a href=/posts/oauthserver/09/>Implement an OAuth 2.0 Server (Part 09)</a></li><li><a href=/posts/oauthserver/08/>Implement an OAuth 2.0 Server (Part 08)</a></li><li><a href=/posts/oauthserver/07/>Implement an OAuth 2.0 Server (Part 07)</a></li><li><a href=/posts/oauthserver/06/>Implement an OAuth 2.0 Server (Part 06)</a></li><li><a href=/posts/oauthserver/05/>Implement an OAuth 2.0 Server (Part 05)</a></li><li><a href=/posts/oauthserver/04/>Implement an OAuth 2.0 Server (Part 04)</a></li><li><a href=/posts/oauthserver/03/>Implement an OAuth 2.0 Server (Part 03)</a></li><li><a href=/posts/oauthserver/02/>Implement an OAuth 2.0 Server (Part 02)</a></li><li><a href=/posts/oauthserver/01/>Implement an OAuth 2.0 Server (Part 01)</a></li></ul></div><div class=post__footer><span><a class=category href=/categories/security/>Security</a><a class=category href=/categories/identity/>Identity</a><a class=category href=/categories/authentication/>Authentication</a><a class=category href=/categories/authorization/>Authorization</a></span>
<span><a class=tag href=/tags/oauth2%2e0/>OAuth2.0</a><a class=tag href=/tags/openidconnect/>OpenIdConnect</a><a class=tag href=/tags/tutorial/>Tutorial</a><a class=tag href=/tags/csharp/>CSharp</a><a class=tag href=/tags/%2enet-core/>.NET Core</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>