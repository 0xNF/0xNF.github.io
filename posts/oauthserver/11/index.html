<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head><title>|
Implement an OAuth 2.0 Server (Part 11)</title><meta charset=utf-8><meta name=generator content="Hugo 0.109.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content><meta name=description content="In this part of our OAuth tutorial, we implement the missing services that help us validate our tokens and write to the database."><link rel=stylesheet href=/scss/main.min.5794be192d21535bdd301561e043a96b6adbad2b5c08279deff459e4661c613f.css integrity="sha256-V5S+GS0hU1vdMBVh4EOpa2rbrStcCCed7/RZ5GYcYT8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://0xnf.github.io/posts/oauthserver/11/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Implement an OAuth 2.0 Server (Part 11)"><meta name=twitter:description content="In this part of our OAuth tutorial, we implement the missing services that help us validate our tokens and write to the database."><meta property="og:title" content="Implement an OAuth 2.0 Server (Part 11)"><meta property="og:description" content="In this part of our OAuth tutorial, we implement the missing services that help us validate our tokens and write to the database."><meta property="og:type" content="article"><meta property="og:url" content="https://0xnf.github.io/posts/oauthserver/11/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-18T18:11:42-07:00"><meta property="article:modified_time" content="2018-06-18T18:11:42-07:00"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/01/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/02/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/03/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/04/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/05/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/06/"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Implement an OAuth 2.0 Server (Part 11)","headline":"Implement an OAuth 2.0 Server (Part 11)","alternativeHeadline":"","description":"
      In this part of our OAuth tutorial, we implement the missing services that help us validate our tokens and write to the database.


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/0xnf.github.io\/posts\/oauthserver\/11\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":{"@type":"Person","name":""},"copyrightYear":"2018","dateCreated":"2018-06-18T18:11:42.00Z","datePublished":"2018-06-18T18:11:42.00Z","dateModified":"2018-06-18T18:11:42.00Z","publisher":{"@type":"Organization","name":null,"url":"https://0xnf.github.io/","logo":{"@type":"ImageObject","url":"https:\/\/0xnf.github.io\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/0xnf.github.io\/posts\/oauthserver\/11\/","wordCount":"1245","genre":["Security","Identity","Authentication","Authorization"],"keywords":["OAuth2.0","OpenIdConnect","Tutorial","CSharp",".NET Core"]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/ alt="profile picture"><div class=sidebar__introduction-title><a href=/></a></div><div class=sidebar__introduction-description><p></p></div></div><ul class=sidebar__list></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Implement an OAuth 2.0 Server (Part 11)</h1><p>Welcome to the eleventh part of a series of posts where we will implement an OAuth 2 Server using <a href=https://github.com/aspnet-contrib/AspNet.Security.OpenIdConnect.Server>AspNet.Security.OpenIdConnectServer</a>.</p><h1 id=services>Services</h1><p>Our methods thus far have been peppered with a reference to a service named <code>ValidationService</code>. This lightweight class is a service that queries our database. Nothing is preventing us from doing these checks inside the <code>OAuthProvider</code> class itself, but the abstraction lends itself to a cleaner batch of methods.</p><p>This is going to be a dependency-injected class that gets resolved by the server in <code>ConfigureServices</code>, so we can inject our database context into it.</p><p>Under <code>Services/</code>, create a new <code>ValidationService.cs</code> file with a new <code>ValidationService</code> class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ValidationService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ApplicationDbContext _context;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ValidationService(ApplicationDbContext context) {
</span></span><span style=display:flex><span>        _context = context;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>bool</span>&gt; CheckClientIdIsValid(<span style=color:#66d9ef>string</span> client_id) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>bool</span>&gt; CheckClientIdAndSecretIsValid(<span style=color:#66d9ef>string</span> client_id, <span style=color:#66d9ef>string</span> client_secret) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>bool</span>&gt; CheckRedirectURIMatchesClientId(<span style=color:#66d9ef>string</span> client_id, <span style=color:#66d9ef>string</span> redirect_uri) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>bool</span>&gt; CheckRefreshTokenIsValid(<span style=color:#66d9ef>string</span> refresh) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>bool</span>&gt; CheckScopesAreValid(<span style=color:#66d9ef>string</span> scope) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=check-client-id-is-valid>Check Client Id is Valid</h3><p>We&rsquo;ll just query the Database to see if any entries with our id exist.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>bool</span>&gt; CheckClientIdIsValid(<span style=color:#66d9ef>string</span> client_id) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (String.IsNullOrWhiteSpace(client_id)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> _context.ClientApplications.AnyAsync(x =&gt; x.ClientId == client_id);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=check-client-id-and-client-secret-is-valid>Check Client Id and Client Secret is Valid</h3><p>Like it says in the comment, you are strongly encouraged to use some form of <code>constant time equals</code> method when validating the client secret, in order to prevent timing attacks. We&rsquo;re lazy, so we won&rsquo;t. We&rsquo;re also on <code>.NET Core 2.0</code> and not <code>.NET Core 2.1</code>, which contains an easy library for this type of thing over at <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.cryptographicoperations.fixedtimeequals?view=netcore-2.1">https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.cryptographicoperations.fixedtimeequals?view=netcore-2.1</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>bool</span>&gt; CheckClientIdAndSecretIsValid(<span style=color:#66d9ef>string</span> client_id, <span style=color:#66d9ef>string</span> client_secret) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (String.IsNullOrWhiteSpace(client_id) || String.IsNullOrWhiteSpace(client_secret)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This could be an easy check, but the ASOS maintainer strongly recommends you to use a fixed-time string compare for client secrets.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This is trivially available in any .NET Core 2.1 or higher framework, but this is a 2.0 project, so we will leave that part out.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If you are on 2.1+, checkout the System.Security.Cryptography.CryptographicOperations.FixedTimeEquals() mehod,</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// available at https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.cryptographicoperations.fixedtimeequals?view=netcore-2.1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> _context.ClientApplications.AnyAsync(x =&gt; x.ClientId == client_id &amp;&amp; x.ClientSecret == client_secret);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=check-redirect-uri-is-valid>Check Redirect URI is valid</h3><p>The OAuth 2.0 specification requires that a supplied redirect uri be a byte-for-byte match with one of the redirect uris that have been registered to an application. <code>http</code> versions of a registered <code>https</code> endpoint are no good, for example.</p><p>We use a double LINQ query to ask these questions of the database.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>bool</span>&gt; CheckRedirectURIMatchesClientId(<span style=color:#66d9ef>string</span> client_id, <span style=color:#66d9ef>string</span> redirect_uri) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (String.IsNullOrWhiteSpace(client_id) || String.IsNullOrWhiteSpace(redirect_uri)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> _context.ClientApplications.Include(x =&gt; x.RedirectURIs).
</span></span><span style=display:flex><span>        AnyAsync(x =&gt; x.ClientId == client_id &amp;&amp;
</span></span><span style=display:flex><span>            x.RedirectURIs.Any(y =&gt; y.URI == redirect_uri));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=check-refresh-token-is-valid>Check Refresh Token is Valid</h3><p>More double linq queries.</p><p>We just want to ask the whether database any such token exists that:</p><ol><li>Has the type <code>refresh_token</code>, and</li><li>Has the value we&rsquo;re looking for.</li></ol><p>Tokens that are revoked or otherwise invalidated are deleted from the database, so any true response is enough of a confirmation that the token is valid.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>bool</span>&gt; CheckRefreshTokenIsValid(<span style=color:#66d9ef>string</span> refresh) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (String.IsNullOrWhiteSpace(refresh)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> _context.ClientApplications.Include(x =&gt; x.UserApplicationTokens).AnyAsync(x =&gt; x.UserApplicationTokens.Any(y =&gt; y.TokenType == OpenIdConnectConstants.TokenUsages.RefreshToken &amp;&amp; y.Value == refresh));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=check-scopes-are-valid>Check Scopes are Valid</h3><p>There&rsquo;s a small curveball here - null or empty scopes are valid, unlike all our other checks.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>bool</span>&gt; CheckScopesAreValid(<span style=color:#66d9ef>string</span> scope) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>string</span>.IsNullOrWhiteSpace(scope)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>; <span style=color:#75715e>// Unlike the other checks, an empty scope is a valid scope. It just means the application has default permissions.</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span>[] scopes = scope.Split(<span style=color:#e6db74>&#39; &#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>string</span> s <span style=color:#66d9ef>in</span> scopes) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (!OAuthScope.NameInScopes(s)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=tokenservice>TokenService</h2><p>Like <code>ValidationService</code>, this small class is a registered dependency-injected service, which we have to handle writing tokens to the database.</p><p>Under <code>Services/</code>, create a new <code>TokenService.cs</code> file with a new <code>TokenService</code> class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TokenService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ApplicationDbContext _context;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> UserManager&lt;ApplicationUser&gt; _userManager;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> TokenService(ApplicationDbContext context, UserManager&lt;ApplicationUser&gt; userManager) {
</span></span><span style=display:flex><span>        _context = context;
</span></span><span style=display:flex><span>        _userManager = userManager;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task WriteNewTokenToDatabase(<span style=color:#66d9ef>string</span> client_id, Token token) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=write-new-token-to-database>Write New Token To Database</h3><p>This method is going to handle writing tokens to our database, along with what to do with old tokens.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task WriteNewTokenToDatabase(<span style=color:#66d9ef>string</span> client_id, Token token, ClaimsPrincipal user = <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (String.IsNullOrWhiteSpace(client_id) || token == <span style=color:#66d9ef>null</span> || String.IsNullOrWhiteSpace(token.GrantType) || String.IsNullOrWhiteSpace(token.Value)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    OAuthClient client = <span style=color:#66d9ef>await</span> _context.ClientApplications.Include(x=&gt;x.Owner).Include(x =&gt; x.UserApplicationTokens).Where(x =&gt; x.ClientId == client_id).FirstOrDefaultAsync();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (client == <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Handling Client Creds</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (token.GrantType == OpenIdConnectConstants.GrantTypes.ClientCredentials) { 
</span></span><span style=display:flex><span>        List&lt;Token&gt; OldClientCredentialTokens = client.UserApplicationTokens.Where(x =&gt; x.GrantType == OpenIdConnectConstants.GrantTypes.ClientCredentials).ToList();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (Token old <span style=color:#66d9ef>in</span> OldClientCredentialTokens) {
</span></span><span style=display:flex><span>            _context.Entry(old).State = EntityState.Deleted;
</span></span><span style=display:flex><span>            client.UserApplicationTokens.Remove(old);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        client.UserApplicationTokens.Add(token);
</span></span><span style=display:flex><span>        _context.Update(client);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> _context.SaveChangesAsync();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Handling the other flows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (token.GrantType == OpenIdConnectConstants.GrantTypes.Implicit || token.GrantType == OpenIdConnectConstants.GrantTypes.AuthorizationCode || token.GrantType == OpenIdConnectConstants.GrantTypes.RefreshToken) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(user == <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ApplicationUser au = <span style=color:#66d9ef>await</span> _userManager.GetUserAsync(user);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (au == <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// These tokens also require association to a specific user</span>
</span></span><span style=display:flex><span>        IEnumerable&lt;Token&gt; OldTokensForGrantType = client.UserApplicationTokens.Where(x =&gt; x.GrantType == token.GrantType &amp;&amp; x.TokenType == token.TokenType).Intersect(au.UserClientTokens).ToList();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (Token old <span style=color:#66d9ef>in</span> OldTokensForGrantType) {
</span></span><span style=display:flex><span>            _context.Entry(old).State = EntityState.Deleted;
</span></span><span style=display:flex><span>            client.UserApplicationTokens.Remove(old);
</span></span><span style=display:flex><span>            au.UserClientTokens.Remove(old);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        client.UserApplicationTokens.Add(token);
</span></span><span style=display:flex><span>        au.UserClientTokens.Add(token);
</span></span><span style=display:flex><span>        _context.ClientApplications.Update(client);
</span></span><span style=display:flex><span>        _context.Users.Update(au);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> _context.SaveChangesAsync();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The operative idea here is that multiple tokens for the same client, user, and grant type shouldn&rsquo;t exist. There should really only ever be one set of tokens matching those characteristics at any given time. When another set is issued, any old ones should be deleted and the new one should take its place. We structure it this way in case any errant duplicates managed to find their way in.</p><p><code>Client Credentials</code> are pretty straightforward because there&rsquo;s no user the tokens are registered to, but the other flows are a little more in-depth.</p><h1 id=register-our-new-services-with-configureservices>Register our new Services with ConfigureServices</h1><p>Like always, we need to register our services so that classes that depend on them can resolve them properly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-csharp data-lang=csharp><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#75715e>// This method gets called by the runtime. Use this method to add services to the container.</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ConfigureServices(IServiceCollection services)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>        options.UseSqlite(Configuration.GetConnectionString(<span style=color:#e6db74>&#34;DefaultConnection&#34;</span>)));
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;((x) =&gt; {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>        x.Password.RequiredLength = <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>        x.Password.RequiredUniqueChars = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>        x.Password.RequireNonAlphanumeric = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>        x.Password.RequireDigit = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>        x.Password.RequireLowercase = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>        x.Password.RequireUppercase = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    })
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>        .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>        .AddDefaultTokenProviders();
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>    services.AddAuthentication()
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>    .AddOpenIdConnectServer(options =&gt; {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>        options.UserinfoEndpointPath = <span style=color:#e6db74>&#34;/api/v1/me&#34;</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>        options.TokenEndpointPath = <span style=color:#e6db74>&#34;/api/v1/token&#34;</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>        options.AuthorizationEndpointPath = <span style=color:#e6db74>&#34;/authorize/&#34;</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>        options.UseSlidingExpiration = <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// False means that new Refresh tokens aren&#39;t issued. Our implementation will be doing a no-expiry refresh, and this is one part of it.</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span>        options.AllowInsecureHttp = <span style=color:#66d9ef>true</span>; <span style=color:#75715e>// ONLY FOR TESTING</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>        options.AccessTokenLifetime = TimeSpan.FromHours(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>// An access token is valid for an hour - after that, a new one must be requested.</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>        options.RefreshTokenLifetime = TimeSpan.FromDays(<span style=color:#ae81ff>365</span> * <span style=color:#ae81ff>1000</span>); <span style=color:#75715e>//NOTE - Later versions of the ASOS library support `TimeSpan?` for these lifetime fields, meaning no expiration. </span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span>                                                                        <span style=color:#75715e>// The version we are using does not, so a long running expiration of one thousand years will suffice.</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span>        options.AuthorizationCodeLifetime = TimeSpan.FromSeconds(<span style=color:#ae81ff>60</span>);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span>        options.IdentityTokenLifetime = options.AccessTokenLifetime;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span>        options.ProviderType = <span style=color:#66d9ef>typeof</span>(OAuthProvider);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span>    });
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span>    <span style=color:#75715e>// Add application services.</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span>    services.AddTransient&lt;IEmailSender, EmailSender&gt;();
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span>    services.AddScoped&lt;OAuthProvider&gt;();
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span>    services.AddTransient&lt;ValidationService&gt;();
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37</span><span>    services.AddTransient&lt;TokenService&gt;();
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39</span><span>    services.AddMvc();
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40</span><span>}</span></span></code></pre></div><h1 id=moving-on>Moving On</h1><p>We&rsquo;re going to take a break here to implement the Authorization Accept/Deny page for our interactive flows.</p><p>The demo of this project to this point can be found <a href=https://github.com/0xNF/OAuthTutorial/tree/11-TokenAndValidationService>here on GitHub</a>.</p><p><a href=/posts/oauthserver/12>Next</a></p><h3>Posts in this series</h3><ul><li><a href=/posts/oauthserver/19/>Implement an OAuth 2.0 Server (Part 19)</a></li><li><a href=/posts/oauthserver/18/>Implement an OAuth 2.0 Server (Part 18)</a></li><li><a href=/posts/oauthserver/17/>Implement an OAuth 2.0 Server (Part 17)</a></li><li><a href=/posts/oauthserver/16/>Implement an OAuth 2.0 Server (Part 16)</a></li><li><a href=/posts/oauthserver/15/>Implement an OAuth 2.0 Server (Part 15)</a></li><li><a href=/posts/oauthserver/14/>Implement an OAuth 2.0 Server (Part 14)</a></li><li><a href=/posts/oauthserver/13/>Implement an OAuth 2.0 Server (Part 13)</a></li><li><a href=/posts/oauthserver/12/>Implement an OAuth 2.0 Server (Part 12)</a></li><li><a href=/posts/oauthserver/11/>Implement an OAuth 2.0 Server (Part 11)</a></li><li><a href=/posts/oauthserver/10/>Implement an OAuth 2.0 Server (Part 10)</a></li><li><a href=/posts/oauthserver/09/>Implement an OAuth 2.0 Server (Part 09)</a></li><li><a href=/posts/oauthserver/08/>Implement an OAuth 2.0 Server (Part 08)</a></li><li><a href=/posts/oauthserver/07/>Implement an OAuth 2.0 Server (Part 07)</a></li><li><a href=/posts/oauthserver/06/>Implement an OAuth 2.0 Server (Part 06)</a></li><li><a href=/posts/oauthserver/05/>Implement an OAuth 2.0 Server (Part 05)</a></li><li><a href=/posts/oauthserver/04/>Implement an OAuth 2.0 Server (Part 04)</a></li><li><a href=/posts/oauthserver/03/>Implement an OAuth 2.0 Server (Part 03)</a></li><li><a href=/posts/oauthserver/02/>Implement an OAuth 2.0 Server (Part 02)</a></li><li><a href=/posts/oauthserver/01/>Implement an OAuth 2.0 Server (Part 01)</a></li></ul></div><div class=post__footer><span><a class=category href=/categories/security/>Security</a><a class=category href=/categories/identity/>Identity</a><a class=category href=/categories/authentication/>Authentication</a><a class=category href=/categories/authorization/>Authorization</a></span>
<span><a class=tag href=/tags/oauth2%2e0/>OAuth2.0</a><a class=tag href=/tags/openidconnect/>OpenIdConnect</a><a class=tag href=/tags/tutorial/>Tutorial</a><a class=tag href=/tags/csharp/>CSharp</a><a class=tag href=/tags/%2enet-core/>.NET Core</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>