<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head><title>|
Implement an OAuth 2.0 Server (Part 09)</title><meta charset=utf-8><meta name=generator content="Hugo 0.109.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content><meta name=description content="This is our first real exposure to the OpenIdConnectServer library - this is part 1 of 2 for setting this class up. We'll handle the Authorization series of methods in this section."><link rel=stylesheet href=/scss/main.min.5794be192d21535bdd301561e043a96b6adbad2b5c08279deff459e4661c613f.css integrity="sha256-V5S+GS0hU1vdMBVh4EOpa2rbrStcCCed7/RZ5GYcYT8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://0xnf.github.io/posts/oauthserver/09/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Implement an OAuth 2.0 Server (Part 09)"><meta name=twitter:description content="This is our first real exposure to the OpenIdConnectServer library - this is part 1 of 2 for setting this class up. We'll handle the Authorization series of methods in this section."><meta property="og:title" content="Implement an OAuth 2.0 Server (Part 09)"><meta property="og:description" content="This is our first real exposure to the OpenIdConnectServer library - this is part 1 of 2 for setting this class up. We'll handle the Authorization series of methods in this section."><meta property="og:type" content="article"><meta property="og:url" content="https://0xnf.github.io/posts/oauthserver/09/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-18T18:11:28-07:00"><meta property="article:modified_time" content="2018-06-18T18:11:28-07:00"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/01/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/02/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/03/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/04/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/05/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/06/"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Implement an OAuth 2.0 Server (Part 09)","headline":"Implement an OAuth 2.0 Server (Part 09)","alternativeHeadline":"","description":"
      This is our first real exposure to the OpenIdConnectServer library - this is part 1 of 2 for setting this class up. We\u0027ll handle the Authorization series of methods in this section.


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/0xnf.github.io\/posts\/oauthserver\/09\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":{"@type":"Person","name":""},"copyrightYear":"2018","dateCreated":"2018-06-18T18:11:28.00Z","datePublished":"2018-06-18T18:11:28.00Z","dateModified":"2018-06-18T18:11:28.00Z","publisher":{"@type":"Organization","name":null,"url":"https://0xnf.github.io/","logo":{"@type":"ImageObject","url":"https:\/\/0xnf.github.io\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/0xnf.github.io\/posts\/oauthserver\/09\/","wordCount":"2052","genre":["Security","Identity","Authentication","Authorization"],"keywords":["OAuth2.0","OpenIdConnect","Tutorial","CSharp",".NET Core"]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/ alt="profile picture"><div class=sidebar__introduction-title><a href=/></a></div><div class=sidebar__introduction-description><p></p></div></div><ul class=sidebar__list></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Implement an OAuth 2.0 Server (Part 09)</h1><p>Welcome to the ninth part of a series of posts where we will implement an OAuth 2 Server using <a href=https://github.com/aspnet-contrib/AspNet.Security.OpenIdConnect.Server>AspNet.Security.OpenIdConnectServer</a>.</p><h1 id=authorization-provider---authorize-methods>Authorization Provider - Authorize Methods</h1><p>It&rsquo;s worth taking a moment to have an overview of how the <code>OpenIdConnectServer</code> library actually works. You are encouraged to read Kevin Chalet&rsquo;s post <a href=https://kevinchalet.com/2016/07/13/creating-your-own-openid-connect-server-with-asos-creating-your-own-authorization-provider/>here</a>.</p><p>An authorization provider is an implementation of the <code>OpenIdConnectServerProvider</code> type which overrides the virtual methods we want to implement. We&rsquo;re going to leave most of these un-overridden, but if you ever need additional functionality, you can always override it and inspect/implement that stage of the pipeline.</p><h2 id=provider-stub>Provider Stub</h2><p>Create a new folder named <code>Providers/</code>, and to it a class named <code>OAuthProvider</code>. Make sure it inherits from <code>OpenIdConnectServerProvider</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OAuthProvider</span> : OpenIdConnectServerProvider {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// TODO it&#39;s empty now, but we&#39;ll fill it in in a bit.</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=startup-registration>Startup Registration</h2><p><code>Startup.cs</code></p><p>We need to add our OAuth server to the middleware pipeline, which we do by calling it on the <code>ConfigureServices()</code> method chain.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-csharp data-lang=csharp><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ConfigureServices(IServiceCollection services) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>    services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>        options.UseSqlite(Configuration.GetConnectionString(<span style=color:#e6db74>&#34;DefaultConnection&#34;</span>)));
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;((x) =&gt; {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>        x.Password.RequiredLength = <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>        x.Password.RequiredUniqueChars = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>        x.Password.RequireNonAlphanumeric = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>        x.Password.RequireDigit = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>        x.Password.RequireLowercase = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>        x.Password.RequireUppercase = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    })
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>        .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>        .AddDefaultTokenProviders();
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>    services.AddAuthentication()
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>        .AddOpenIdConnectServer(options =&gt; {
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>            options.UserinfoEndpointPath = <span style=color:#e6db74>&#34;/api/v1/me&#34;</span>;
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>            options.TokenEndpointPath = <span style=color:#e6db74>&#34;/api/v1/token&#34;</span>;
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>            options.AuthorizationEndpointPath = <span style=color:#e6db74>&#34;/authorize/&#34;</span>;
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>            options.UseSlidingExpiration = <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// False means that new Refresh tokens aren&#39;t issued. Our implementation will be doing a no-expiry refresh, and this is one part of it.</span>
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>            options.AllowInsecureHttp = <span style=color:#66d9ef>true</span>; <span style=color:#75715e>// ONLY FOR TESTING</span>
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>            options.AccessTokenLifetime = TimeSpan.FromHours(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>// An access token is valid for an hour - after that, a new one must be requested.</span>
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span>            options.RefreshTokenLifetime = TimeSpan.FromDays(<span style=color:#ae81ff>365</span> * <span style=color:#ae81ff>1000</span>); <span style=color:#75715e>//NOTE - Later versions of the ASOS library support `TimeSpan?` for these lifetime fields, meaning no expiration. </span>
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>                                                                            <span style=color:#75715e>// The version we are using does not, so a long running expiration of one thousand years will suffice.</span>
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>            options.AuthorizationCodeLifetime = TimeSpan.FromSeconds(<span style=color:#ae81ff>60</span>);
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span>            options.IdentityTokenLifetime = options.AccessTokenLifetime;
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span>            options.ProviderType = <span style=color:#66d9ef>typeof</span>(OAuthProvider);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span>        });
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span>    <span style=color:#75715e>// Add application services.</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span>    services.AddTransient&lt;IEmailSender, EmailSender&gt;();
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span>    services.AddScoped&lt;OAuthProvider&gt;();
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span>    services.AddMvc();
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span>}</span></span></code></pre></div><p>Let&rsquo;s investigate each assignment:</p><p><code>UserinfoEndpointPage</code> is where any authorized applications know to go for user information. This is more of an OpenIdConnect feature than OAuth feature, but we&rsquo;re implementing a user endpoint anyway, so we&rsquo;ll notify our server of it here.</p><p><code>TokenEndpointPath</code> is where the server knows to send incoming requests that want a Token. This is for <code>Client Credentials</code>, and <code>Refresh Token</code> grants.</p><p><code>AuthorizationEndpointPath</code> is for interactive flows like <code>Implicit (token)</code> and the beginning of their <code>Authorization Code</code> flows.</p><p><code>UseSlidingExpiration</code> is so that ASOS knows not to try to regenerate a refresh token. You may have different requirements, but in our implementation, a user is given only one refresh token, unless other things like their security stamp changes.</p><p><code>AllowInsecureHttp</code> is strongly recommended to be set top <code>false</code> in production - we have it set to <code>true</code> here because SSL certs on our dev machine are a bit of a pain. If any incoming request that is handled by this middleware is not <code>http</code> if this is set to true, it will automatically fail.</p><p><code>AccesTokenLifeTime</code> is how long an access token is valid for - if a user supplied an access token past its expiration, the request is rejected.</p><p><code>RefreshTokenLifetime</code> is the same for a refresh token. Like the comment says, later versions of ASOS allow for nullable <code>TimeSpan?</code> for infinite lifetimes - but we&rsquo;ll make do with 1,000 years here.</p><p><code>IdentityTokenLifeTime</code> is a feature of the <code>OpenIdConnect</code> spec, which is tangential to what we&rsquo;re implementing - but if you do decide to implement it, it&rsquo;s fine to have it set to the same as the access token.</p><p><code>ProviderType</code> is how the service knows what provider to use - you could potentially have multiple different providers, and in theory, multiple different instances of an OpenIdConnectServer running. We&rsquo;re making sure that this instance knows to use our custom one. There are a few other ways to specify the provider, including in-line object creation, or setting the concrete instance of the provider with <code>Options.Provider</code>, but we&rsquo;re sticking with type resolution.</p><p>That means we also have to register our provider as a <code>ScopedService</code>, which lets the server dynamically resolve the provider as needed.</p><h2 id=filling-in-the-provider>Filling in the Provider</h2><p><code>Providers/OAuthProvider.cs</code>:</p><p>We&rsquo;re going to stub out all the methods we&rsquo;re interested in implementing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OAuthProvider</span> : OpenIdConnectServerProvider {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// These doesn&#39;t exist yet - but they will further down.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> ValidationService VService;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> TokenService TService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> Task MatchEndpoint(MatchEndpointContext context) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Task.CompletedTask;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#region Authorization Requests</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>async</span> Task ValidateAuthorizationRequest(ValidateAuthorizationRequestContext context) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>base</span>.ValidateAuthorizationRequest(context);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>async</span> Task ApplyAuthorizationResponse(ApplyAuthorizationResponseContext context) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>base</span>.ApplyAuthorizationResponse(context);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>endregion
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#region Token Requests</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>async</span> Task ValidateTokenRequest(ValidateTokenRequestContext context) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>base</span>.ValidateTokenRequest(context);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> Task HandleTokenRequest(HandleTokenRequestContext context) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>base</span>.HandleTokenRequest(context);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>async</span> Task ApplyTokenResponse(ApplyTokenResponseContext context) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>base</span>.ApplyTokenResponse(context);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span>endregion
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The control flow of the ASOS library is for a given endpoint registered to it is to flow through <code>Validate</code>, then to <code>Handle</code>, then to <code>Apply</code>.</p><p>For example, because we&rsquo;ve told ASOS that our Token endpoint is <code>/api/v1/token</code>, any incoming http request to our server at that path will be sent to the <code>TokenRequest</code> line of methods. First it will be passed to <code>ValidateTokenRequest</code>, then to <code>HandleTokenRequest</code>, then to <code>ApplyTokenResponse</code>. At any stage, a request may be rejected and returned to the user immediately. If that happens, the remaining methods will not be executed.</p><p>In the most minimal possible of all ASOS set ups, it&rsquo;s not necessary to override all of the available virtual methods - in fact, we don&rsquo;t even have to override the ones we&rsquo;re going to. In order for ASOS to minimally function, you only need to implement <code>ValidateAuthorizationRequest</code> and <code>ValidateTokenRequest</code> - You&rsquo;ll be left with a barely functional server, but it will work.</p><p>One thing to note is that although the flow is from validate, to handle, to apply, we don&rsquo;t need to implement each step unless we really want to - for instance, we are not implementing <code>HandleAuthorizationRequest</code>. We are essentially going to outsource the events that would normally be under its purview to a different part of our application later.</p><p>Side note 1: if you want to complain about <code>#region</code>, don&rsquo;t. <a href=/posts/misc/regionisfine>They are completely fine</a>.</p><p>Side note 2: Before the Validate method in a given control flow is executed, an Extract method runs before it. We can override this if we have a custom/non-standard way of performing an authorization or token request. This is a good solution for handling legacy systems. If you&rsquo;re starting from scratch, or the old implementations were standards compliant, then there is no need to override these methods.</p><h2 id=difference-between-authorization-and-token-requests>Difference between Authorization and Token requests</h2><h3 id=authorization>Authorization</h3><p>Two of the three main OAuth 2.0 flows, the <code>Implicit Grant</code> and <code>Authorization Code</code>, require user authorization. These flows are interactive and require presenting the user with information about the application, the scopes it permissions its requesting, and the opportunity for the user to accept or reject the request.</p><p>That is what is handled by the <code>Authorization</code> series of methods.</p><h3 id=token>Token</h3><p>Once an application has already received authorization, or if it is an authorization-free flow like <code>Client Credentials</code>, it can request a token. For example, in the <code>Authorization Code</code> flow, an application will first ask hit up the <code>Authorization</code> endpoint, and then send the received <code>code</code> to the <code>Token</code> endpoint to receive its tokens.</p><p>Once that same application needs another token, it will send its <code>refresh token</code> back to the <code>Token</code> endpoint to receive a new <code>access token</code>. The application has already been authorized - it just needs another token.</p><p>The tl;dr is that <code>Token</code> is how you get a token, but <code>Authorization</code> is how you get permission to get a token.</p><h2 id=match-endpoint>Match Endpoint</h2><p>Before we can work on the Validation methods, we need to do something with <code>MatchEndpoint</code>.</p><p><code>ASOS</code> is by default very conservative, and doesn&rsquo;t accept anything outside a strictly defined set of endpoints. If we want to implement the interactive flows, it&rsquo;d be nice if we had just one page the user could be redirected to, where they could <code>accept</code> or <code>deny</code> a request.</p><p>If we want the library to accept this user-friendly sequence of events, we&rsquo;ll have to define how the library should respond to requests that come its way.</p><p>We&rsquo;ve already defined our <code>authorization</code> endpoint as being at <code>/authorize/</code>, as seen when we registered the server with <code>startup</code>, so we&rsquo;ll just use that endpoint as the check for redirection.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> Task MatchEndpoint(MatchEndpointContext context) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (context.Options.AuthorizationEndpointPath.HasValue &amp;&amp;
</span></span><span style=display:flex><span>        context.Request.Path.Value.StartsWith(context.Options.AuthorizationEndpointPath)) {
</span></span><span style=display:flex><span>        context.MatchAuthorizationEndpoint();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Task.CompletedTask;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre><code>It's also common in setups like this to include the Revocation endpoint here as well - our revocation implementation will be different, so we won't include it here, but feel free to add it to the match endpoint list.
</code></pre><h2 id=validate-authorization-request>Validate Authorization Request</h2><p>This is the first function in the Authorization flow that is called. Here we extract the necessary information from the incoming request and check that it&rsquo;s all valid:</p><ul><li>The supplied client id needs to exist</li><li>The redirect uri cannot be empty and must be properly registered to the client</li><li>If scopes are requested, they must not be bogus</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>async</span> Task ValidateAuthorizationRequest(ValidateAuthorizationRequestContext context) {
</span></span><span style=display:flex><span>    VService = context.HttpContext.RequestServices.GetRequiredService&lt;ValidationService&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(!context.Request.IsAuthorizationCodeFlow() &amp;&amp; !context.Request.IsImplicitFlow()) {
</span></span><span style=display:flex><span>        context.Reject(
</span></span><span style=display:flex><span>            error: OpenIdConnectConstants.Errors.UnsupportedResponseType,
</span></span><span style=display:flex><span>            description: <span style=color:#e6db74>&#34;Only authorization code, refresh token, and token grant types are accepted by this authorization server.&#34;</span>
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> clientid = context.ClientId;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> rdi = context.Request.RedirectUri;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> state = context.Request.State;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> scope = context.Request.Scope;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (String.IsNullOrWhiteSpace(clientid)) {
</span></span><span style=display:flex><span>        context.Reject(
</span></span><span style=display:flex><span>                    error: OpenIdConnectConstants.Errors.InvalidClient,
</span></span><span style=display:flex><span>                    description: <span style=color:#e6db74>&#34;client_id cannot be empty&#34;</span>
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (String.IsNullOrWhiteSpace(rdi)) {
</span></span><span style=display:flex><span>        context.Reject(
</span></span><span style=display:flex><span>                    error: OpenIdConnectConstants.Errors.InvalidClient,
</span></span><span style=display:flex><span>                    description: <span style=color:#e6db74>&#34;redirect_uri cannot be empty&#34;</span>
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (!<span style=color:#66d9ef>await</span> VService.CheckClientIdIsValid(clientid)) {
</span></span><span style=display:flex><span>        context.Reject(
</span></span><span style=display:flex><span>                    error: OpenIdConnectConstants.Errors.InvalidClient,
</span></span><span style=display:flex><span>                    description: <span style=color:#e6db74>&#34;The supplied client id does not exist&#34;</span>
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (!<span style=color:#66d9ef>await</span> VService.CheckRedirectURIMatchesClientId(clientid, rdi)) {
</span></span><span style=display:flex><span>        context.Reject(
</span></span><span style=display:flex><span>                    error: OpenIdConnectConstants.Errors.InvalidClient,
</span></span><span style=display:flex><span>                    description: <span style=color:#e6db74>&#34;The supplied redirect uri is incorrect&#34;</span>
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (! <span style=color:#66d9ef>await</span> VService.CheckScopesAreValid(scope)) {
</span></span><span style=display:flex><span>        context.Reject(
</span></span><span style=display:flex><span>                error: OpenIdConnectConstants.Errors.InvalidRequest,
</span></span><span style=display:flex><span>                description: <span style=color:#e6db74>&#34;One or all of the supplied scopes are invalid&#34;</span>
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    } 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    context.Validate();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>If any one of these conditions fail, we reject the request, which returns to the user with the error message indicated. Otherwise, we assert that the incoming request is valid, and move on.</p><p>Notably at the top, we reject a request that isn&rsquo;t either for an <code>authorization_code</code> or for <code>implicit grant</code>. When it comes to the authorization endpoints, these are the only two we are concerned with. Other token requests are handled elsewhere.</p><pre><code>If you're playing around yourself, be aware that some information can only be found on the context.Request or context.HttpContext items.
</code></pre><h2 id=apply-authorization-request>Apply Authorization Request</h2><p>We don&rsquo;t need to implement <code>HandleAuthorizationRequest</code> because its functions will be implemented in a different section, but we do need to implement <code>ApplyAuthorizationResponse</code>. The only type of OAuth flow that makes it this far is the <code>Implicit Grant</code>, so we can safely treat this function as issuing only implicit grant tokens. This can be a bit confusing - we are issuing an access token from an authorization endpoint, but that&rsquo;s an artifact of the way Implicit Grants work.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>async</span> Task ApplyAuthorizationResponse(ApplyAuthorizationResponseContext context) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (!String.IsNullOrWhiteSpace(context.Error)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    TService = context.HttpContext.RequestServices.GetRequiredService&lt;TokenService&gt;();
</span></span><span style=display:flex><span>    ApplicationDbContext db = context.HttpContext.RequestServices.GetRequiredService&lt;ApplicationDbContext&gt;();
</span></span><span style=display:flex><span>    ClaimsPrincipal claimsUser = context.HttpContext.User;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Implicit grant is the only flow that gets their token issued here.</span>
</span></span><span style=display:flex><span>    Token access = <span style=color:#66d9ef>new</span> Token() {
</span></span><span style=display:flex><span>        GrantType = OpenIdConnectConstants.GrantTypes.Implicit,
</span></span><span style=display:flex><span>        TokenType = OpenIdConnectConstants.TokenUsages.AccessToken,
</span></span><span style=display:flex><span>        Value = context.AccessToken,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    OAuthClient client = db.ClientApplications.First(x =&gt; x.ClientId == context.Request.ClientId);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (client == <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> TService.WriteNewTokenToDatabase(context.Request.ClientId, access, claimsUser);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The first step is to check if there was an error - rejected contexts, or contexts that have otherwise suffered some kind of error have a non-null <code>Error</code> field, a string for the error message. If we somehow get this far with an invalid context, we&rsquo;d like to leave before we do more work.</p><p>We ask for the ApplicationDbService in the event that the authoring OAuth client has been deleted between when the token has been requested and when it is granted. If it&rsquo;s MIA, we leave before persisting the token.</p><p>Again, we&rsquo;ll cover the implementations of TokenService and ValidationService later.</p><h1 id=moving-on>Moving On</h1><p>The demo of this project to this point can be found <a href=https://github.com/0xNF/OAuthTutorial/tree/09-OAuthProviderA>here on GitHub</a>.</p><p>In the next section we&rsquo;ll implement the three token methods.<br><a href=/posts/oauthserver/10>Next</a></p><h3>Posts in this series</h3><ul><li><a href=/posts/oauthserver/19/>Implement an OAuth 2.0 Server (Part 19)</a></li><li><a href=/posts/oauthserver/18/>Implement an OAuth 2.0 Server (Part 18)</a></li><li><a href=/posts/oauthserver/17/>Implement an OAuth 2.0 Server (Part 17)</a></li><li><a href=/posts/oauthserver/16/>Implement an OAuth 2.0 Server (Part 16)</a></li><li><a href=/posts/oauthserver/15/>Implement an OAuth 2.0 Server (Part 15)</a></li><li><a href=/posts/oauthserver/14/>Implement an OAuth 2.0 Server (Part 14)</a></li><li><a href=/posts/oauthserver/13/>Implement an OAuth 2.0 Server (Part 13)</a></li><li><a href=/posts/oauthserver/12/>Implement an OAuth 2.0 Server (Part 12)</a></li><li><a href=/posts/oauthserver/11/>Implement an OAuth 2.0 Server (Part 11)</a></li><li><a href=/posts/oauthserver/10/>Implement an OAuth 2.0 Server (Part 10)</a></li><li><a href=/posts/oauthserver/09/>Implement an OAuth 2.0 Server (Part 09)</a></li><li><a href=/posts/oauthserver/08/>Implement an OAuth 2.0 Server (Part 08)</a></li><li><a href=/posts/oauthserver/07/>Implement an OAuth 2.0 Server (Part 07)</a></li><li><a href=/posts/oauthserver/06/>Implement an OAuth 2.0 Server (Part 06)</a></li><li><a href=/posts/oauthserver/05/>Implement an OAuth 2.0 Server (Part 05)</a></li><li><a href=/posts/oauthserver/04/>Implement an OAuth 2.0 Server (Part 04)</a></li><li><a href=/posts/oauthserver/03/>Implement an OAuth 2.0 Server (Part 03)</a></li><li><a href=/posts/oauthserver/02/>Implement an OAuth 2.0 Server (Part 02)</a></li><li><a href=/posts/oauthserver/01/>Implement an OAuth 2.0 Server (Part 01)</a></li></ul></div><div class=post__footer><span><a class=category href=/categories/security/>Security</a><a class=category href=/categories/identity/>Identity</a><a class=category href=/categories/authentication/>Authentication</a><a class=category href=/categories/authorization/>Authorization</a></span>
<span><a class=tag href=/tags/oauth2%2e0/>OAuth2.0</a><a class=tag href=/tags/openidconnect/>OpenIdConnect</a><a class=tag href=/tags/tutorial/>Tutorial</a><a class=tag href=/tags/csharp/>CSharp</a><a class=tag href=/tags/%2enet-core/>.NET Core</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>