<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head><title>|
Implement an OAuth 2.0 Server (Part 13)</title><meta charset=utf-8><meta name=generator content="Hugo 0.109.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content><meta name=description content="Here we work with Identity, Claims, and Authorization tickets so that the OpenIdConnectServer library can generate a valid and useful access token for our users."><link rel=stylesheet href=/scss/main.min.5794be192d21535bdd301561e043a96b6adbad2b5c08279deff459e4661c613f.css integrity="sha256-V5S+GS0hU1vdMBVh4EOpa2rbrStcCCed7/RZ5GYcYT8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://0xnf.github.io/posts/oauthserver/13/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Implement an OAuth 2.0 Server (Part 13)"><meta name=twitter:description content="Here we work with Identity, Claims, and Authorization tickets so that the OpenIdConnectServer library can generate a valid and useful access token for our users."><meta property="og:title" content="Implement an OAuth 2.0 Server (Part 13)"><meta property="og:description" content="Here we work with Identity, Claims, and Authorization tickets so that the OpenIdConnectServer library can generate a valid and useful access token for our users."><meta property="og:type" content="article"><meta property="og:url" content="https://0xnf.github.io/posts/oauthserver/13/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-18T18:11:45-07:00"><meta property="article:modified_time" content="2018-06-18T18:11:45-07:00"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/01/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/02/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/03/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/04/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/05/"><meta property="og:see_also" content="https://0xnf.github.io/posts/oauthserver/06/"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Implement an OAuth 2.0 Server (Part 13)","headline":"Implement an OAuth 2.0 Server (Part 13)","alternativeHeadline":"","description":"
      Here we work with Identity, Claims, and Authorization tickets so that the OpenIdConnectServer library can generate a valid and useful access token for our users.


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/0xnf.github.io\/posts\/oauthserver\/13\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":{"@type":"Person","name":""},"copyrightYear":"2018","dateCreated":"2018-06-18T18:11:45.00Z","datePublished":"2018-06-18T18:11:45.00Z","dateModified":"2018-06-18T18:11:45.00Z","publisher":{"@type":"Organization","name":null,"url":"https://0xnf.github.io/","logo":{"@type":"ImageObject","url":"https:\/\/0xnf.github.io\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/0xnf.github.io\/posts\/oauthserver\/13\/","wordCount":"1463","genre":["Security","Identity","Authentication","Authorization"],"keywords":["OAuth2.0","OpenIdConnect","Tutorial","CSharp",".NET Core"]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/ alt="profile picture"><div class=sidebar__introduction-title><a href=/></a></div><div class=sidebar__introduction-description><p></p></div></div><ul class=sidebar__list></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Implement an OAuth 2.0 Server (Part 13)</h1><p>Welcome to the thirteenth part of a series of posts where we will implement an OAuth 2 Server using <a href=https://github.com/aspnet-contrib/AspNet.Security.OpenIdConnect.Server>AspNet.Security.OpenIdConnectServer</a>.</p><h1 id=identity-claims-and-authorization-tickets>Identity, Claims, and Authorization Tickets</h1><p>We&rsquo;ve been skirting talking about claims and authentication tickets by hiding all of it behind our <code>TicketCounter</code> class. You can get a in-depth overview of what those are over at the <a href=https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model#claims>Microsoft Docs</a>.</p><p>Claims are how the ASP.NET team has approached identity and authorization details since about 2016. The short of it is that claims are a way of specifying permissions - certain things have claims, other things have claim requirements, and if your claim matches the claims requirement, then you can access the resource locked behind the claim. They&rsquo;re a bit like <code>roles</code>, but more low level: roles are just a special claim on an <code>IdentityUser</code>.</p><p>A collection of claims represents an <code>Identity</code>, specifically in our circumstances, they&rsquo;re represented by the <code>ClaimsIdentity</code> class. Identity is itself a complicated topic, but it&rsquo;s the fundamental unit behind what we&rsquo;re doing setting up an OAuth server in the first place. Identities and Claims are the two pillars of the &lsquo;I&rsquo; and the &lsquo;A&rsquo; of Identity and Access Management. The &lsquo;M&rsquo; is the easily revocable and scope-separated OAuth layer we&rsquo;re adding.</p><p>Finally, an <code>AuthenticationTicket</code> is a container for one or more identities belonging to a single owning-entity. It&rsquo;s possible for me to have multiple accounts on one service for instance - this would help resolve that. Importantly, it also holds the authentication scheme in charge of handling the authentication process when the server receives the ticket. For our tutorial, we give it the ASOS default of <code>OpenIdConnectServerDefaults.AuthenticationScheme</code>.</p><p>We didn&rsquo;t register that explicitly in startup, but because it is the default setting whenever an instance of <code>OpenIdConnectServer</code> is registered, it is implicitly specified to be associated with that same authentication scheme.</p><p>When it comes to creating AuthenticationTickets though, we do have to explicitly specify what scheme want to handle it - so in all the tickets we generate, we&rsquo;ll be supplying that same scheme.</p><h1 id=ticketcounter>TicketCounter</h1><p>Under <code>Providers/</code>, stub out a static <code>TicketCounter</code> class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TicketCounter</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> AuthenticationTicket MakeClaimsForClientCredentials(<span style=color:#66d9ef>string</span> clientId) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> AuthenticationTicket MakeClaimsForInteractive(ApplicationUser user, AuthorizeViewModel authorizeViewModel) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo; static because we have no need to ever instantiate it.</p><h2 id=client-credentials>Client Credentials</h2><p>Because Client Credentials do not involve any user, we have to fudge what it means to have an &ldquo;Identity&rdquo;. What we&rsquo;re going to do is set the identity to be the client requesting access to the server, and then we&rsquo;ll just make a note of its grant type.</p><p>When we deserialize these claims later, it&rsquo;ll be impossible to distinguish from the subject id what is meant to be a <code>user</code> versus what is a <code>client</code>, so the grant type claim will help us differentiate.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> AuthenticationTicket MakeClaimsForClientCredentials(<span style=color:#66d9ef>string</span> clientId) {
</span></span><span style=display:flex><span>    ClaimsIdentity identity = <span style=color:#66d9ef>new</span> ClaimsIdentity(OpenIdConnectServerDefaults.AuthenticationScheme, OpenIdConnectConstants.Claims.Name, OpenIdConnectConstants.Claims.Role);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    identity.AddClaim(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Claim(OpenIdConnectConstants.Claims.Subject, clientId)
</span></span><span style=display:flex><span>            .SetDestinations(OpenIdConnectConstants.Destinations.AccessToken));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We serialize the grant_type so we can user discriminate rate-limits. AuthorizationCode grants typically have the highest rate-limit allowance</span>
</span></span><span style=display:flex><span>    identity.AddClaim(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(<span style=color:#e6db74>&#34;grant_type&#34;</span>, OpenIdConnectConstants.GrantTypes.ClientCredentials)
</span></span><span style=display:flex><span>                .SetDestinations(OpenIdConnectConstants.Destinations.AccessToken));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We serialize the client_id so we can monitor for usage patterns of a given app, and also to allow for app-based token revokes.</span>
</span></span><span style=display:flex><span>    identity.AddClaim(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(<span style=color:#e6db74>&#34;client_id&#34;</span>, clientId)
</span></span><span style=display:flex><span>                .SetDestinations(OpenIdConnectConstants.Destinations.AccessToken));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    AuthenticationTicket ticket = <span style=color:#66d9ef>new</span> AuthenticationTicket(<span style=color:#66d9ef>new</span> ClaimsPrincipal(identity), <span style=color:#66d9ef>new</span> AuthenticationProperties(), OpenIdConnectServerDefaults.AuthenticationScheme);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// In our implementation, an access token is valid for a single hour.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ticket;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Take note of the fact that ASOS requires a <code>ClaimsIdentity</code> with a <code>Subject</code> claim in order to work properly. Typically this represents a more formal identity like a user, but here we&rsquo;ll make it work with the client.</p><p>Also take note of the fact that we call <code>SetDestinations</code> on every claim that we create - this is an extension method from ASOS under <code>AspNet.Security.OpenIdConnect.Extensions</code>. Kevin Chalet explains it in his blog posts, but unless a destination is manually specified like it is here, ASOS will refuse to serialize anything into a token for fear of leaking data.</p><p>All this to say that simply adding a claim and expecting it to work won&rsquo;t produce the results you want - you&rsquo;ll find that upon deserialization the fields you added are missing.</p><h2 id=interactive-claims>Interactive Claims</h2><p>The claims and ticket constructed from using the interactive authorization flows are more complicated than the client credentials claims.</p><p>Because we&rsquo;re dealing with a user now, we have to find some way to put their information into the ticket. To do this, we add a <code>NameIdentifier</code> claim with the user&rsquo;s id, we add <code>Name</code> claim with the user&rsquo;s user name, and we manually include the Security Stamp as well.</p><p>The SecurityStamp is an ASP.NET Identity feature that implements a cryptographic hash of all the attributes of a user that are important from an identity and access standpoint. If the user&rsquo;s email changes, the stamp changes. If the user&rsquo;s password changes, the stamp changes. If you have some kind of user biography or self-description and that changes, the stamp does not change.</p><p>The stamp only changes whenever something affecting a users fundamental identity attributes change - this is a way for us to know if a given token is invalid because it was assigned to a user who had critical details changed.</p><p>This ticket that we&rsquo;re creating with the user&rsquo;s identity will allow us down the line to actually sign in with the user without their involvement - which is a neat trick, especially for applications that will interact on their behalf.</p><p>Additionally, we include details that aren&rsquo;t just related to identity, but are instead related to the users access to our servers through the requesting client. We include things like the grant type and the client id.</p><p>This will help us later when we deserialize the token and implement our actual authorization. For example, knowing the grant type will let us discriminate what kind of rate limit we should give the token - the more heavy weight a token the better rate limits they&rsquo;ll be able to get.</p><p>We also need to know the client id upon deserialization in order to check if a token still has access to the server - a deleted client is invalid, a client that has been rate-limited should be denied access, etc.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> AuthenticationTicket MakeClaimsForInteractive(ApplicationUser user, AuthorizeViewModel authorizeViewModel) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>        *  If you want to issue an OpenId Token, the spec for which is available at https://openid.net/connect/
</span></span></span><span style=display:flex><span><span style=color:#75715e>        *  Then in each of the SetDestinations, add a reference to OpenIdConnect.Destinations.IdentityToken, like so:
</span></span></span><span style=display:flex><span><span style=color:#75715e>        *  
</span></span></span><span style=display:flex><span><span style=color:#75715e>        *  new Claim(&#34;grant_type&#34;, OpenIdConnectConstants.GrantTypes.AuthorizationCode)
</span></span></span><span style=display:flex><span><span style=color:#75715e>        *         .SetDestinations(OpenIdConnectConstants.Destinations.AccessToken, OpenIdConnectConstants.Destinations.IdentityToken));
</span></span></span><span style=display:flex><span><span style=color:#75715e>        *         
</span></span></span><span style=display:flex><span><span style=color:#75715e>        *   This ensures that the claims you are concerned about will be placed into the Identity Token, which other services may access.
</span></span></span><span style=display:flex><span><span style=color:#75715e>        */</span>
</span></span><span style=display:flex><span>    ClaimsIdentity identity = <span style=color:#66d9ef>new</span> ClaimsIdentity(OpenIdConnectServerDefaults.AuthenticationScheme, OpenIdConnectConstants.Claims.Name, OpenIdConnectConstants.Claims.Role);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    identity.AddClaim(<span style=color:#66d9ef>new</span> Claim(ClaimTypes.NameIdentifier, user.Id).SetDestinations(OpenIdConnectConstants.Destinations.AccessToken));
</span></span><span style=display:flex><span>    identity.AddClaim(<span style=color:#66d9ef>new</span> Claim(ClaimTypes.Name, user.NormalizedUserName).SetDestinations(OpenIdConnectConstants.Destinations.AccessToken));
</span></span><span style=display:flex><span>    identity.AddClaim(<span style=color:#66d9ef>new</span> Claim(<span style=color:#e6db74>&#34;AspNet.Identity.SecurityStamp&#34;</span>, user.SecurityStamp).SetDestinations(OpenIdConnectConstants.Destinations.AccessToken));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We serialize the user_id so we can determine which user the caller of this token is</span>
</span></span><span style=display:flex><span>    identity.AddClaim(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(OpenIdConnectConstants.Claims.Subject, user.Id)
</span></span><span style=display:flex><span>                .SetDestinations(OpenIdConnectConstants.Destinations.AccessToken));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We serialize the grant_type so we can user discriminate rate-limits. AuthorizationCode grants typically have the highest rate-limit allowance</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (authorizeViewModel.ResponseType == OpenIdConnectConstants.ResponseTypes.Code) {
</span></span><span style=display:flex><span>        identity.AddClaim(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(<span style=color:#e6db74>&#34;grant_type&#34;</span>, OpenIdConnectConstants.GrantTypes.AuthorizationCode)
</span></span><span style=display:flex><span>                .SetDestinations(OpenIdConnectConstants.Destinations.AccessToken));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (authorizeViewModel.ResponseType == OpenIdConnectConstants.ResponseTypes.Token) {
</span></span><span style=display:flex><span>        identity.AddClaim(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(<span style=color:#e6db74>&#34;grant_type&#34;</span>, OpenIdConnectConstants.GrantTypes.Implicit)
</span></span><span style=display:flex><span>                .SetDestinations(OpenIdConnectConstants.Destinations.AccessToken));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We serialize the client_id so we can monitor for usage patterns of a given app, and also to allow for app-based token revokes.</span>
</span></span><span style=display:flex><span>    identity.AddClaim(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(<span style=color:#e6db74>&#34;client_id&#34;</span>, authorizeViewModel.ClientId)
</span></span><span style=display:flex><span>                .SetDestinations(OpenIdConnectConstants.Destinations.AccessToken));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    AuthenticationTicket ticket = <span style=color:#66d9ef>new</span> AuthenticationTicket(<span style=color:#66d9ef>new</span> ClaimsPrincipal(identity), <span style=color:#66d9ef>new</span> AuthenticationProperties(), OpenIdConnectServerDefaults.AuthenticationScheme);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ICollection&lt;<span style=color:#66d9ef>string</span>&gt; scopesToAdd = <span style=color:#66d9ef>new</span> List&lt;<span style=color:#66d9ef>string</span>&gt;() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* If  you&#39;ve chosen to add an OpenId token to your destinations, be sure to include the OpenIdCOnnectConstants.Scopes.OpenId in this list */</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//OpenIdConnectConstants.Scopes.OpenId, // Lets our requesting clients know that an OpenId Token was generated with the original request.</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (authorizeViewModel.ResponseType == OpenIdConnectConstants.ResponseTypes.Code) {
</span></span><span style=display:flex><span>        scopesToAdd.Add(OpenIdConnectConstants.Scopes.OfflineAccess); <span style=color:#75715e>//Gives us a RefreshToken, only do this if we&#39;re following the `Authorization Code` flow. For `Implicit Grant`, we don&#39;t supply a refresh token.    </span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>string</span> s <span style=color:#66d9ef>in</span> authorizeViewModel.Scopes) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (OAuthScope.NameInScopes(s)) {
</span></span><span style=display:flex><span>            scopesToAdd.Add(s);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ticket.SetScopes(scopesToAdd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ticket;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pay attention to the comments regarding the OpenId token - we&rsquo;re not implementing that in this tutorial, but if you are, this is the spot to add it in.</p><p>One quirk of the ASOS library to be aware of is that in order to get a refresh token, you have to add the <code>OfflineAccess</code> scope. That is not a self-explanatory description of a refresh token, but that&rsquo;s the only way to get one.</p><p>And of course, you should only issue a refresh token if the grant type is for a <code>Code</code>, or depending on the requirements, for a grant type of <code>refresh_token</code>.</p><p>Finally, we have to add the scopes the client requested to the ticket.</p><h1 id=moving-on>Moving On</h1><p>The demo of this project to this point can be found <a href=https://github.com/0xNF/OAuthTutorial/tree/13-Claims>here on GitHub</a>.</p><p>In the next section we&rsquo;ll enable OAuth authentication for our endpoints, including handling scopes using ASP.NET <code>Polcies</code>.</p><p><a href=/posts/oauthserver/14>Next</a></p><h3>Posts in this series</h3><ul><li><a href=/posts/oauthserver/19/>Implement an OAuth 2.0 Server (Part 19)</a></li><li><a href=/posts/oauthserver/18/>Implement an OAuth 2.0 Server (Part 18)</a></li><li><a href=/posts/oauthserver/17/>Implement an OAuth 2.0 Server (Part 17)</a></li><li><a href=/posts/oauthserver/16/>Implement an OAuth 2.0 Server (Part 16)</a></li><li><a href=/posts/oauthserver/15/>Implement an OAuth 2.0 Server (Part 15)</a></li><li><a href=/posts/oauthserver/14/>Implement an OAuth 2.0 Server (Part 14)</a></li><li><a href=/posts/oauthserver/13/>Implement an OAuth 2.0 Server (Part 13)</a></li><li><a href=/posts/oauthserver/12/>Implement an OAuth 2.0 Server (Part 12)</a></li><li><a href=/posts/oauthserver/11/>Implement an OAuth 2.0 Server (Part 11)</a></li><li><a href=/posts/oauthserver/10/>Implement an OAuth 2.0 Server (Part 10)</a></li><li><a href=/posts/oauthserver/09/>Implement an OAuth 2.0 Server (Part 09)</a></li><li><a href=/posts/oauthserver/08/>Implement an OAuth 2.0 Server (Part 08)</a></li><li><a href=/posts/oauthserver/07/>Implement an OAuth 2.0 Server (Part 07)</a></li><li><a href=/posts/oauthserver/06/>Implement an OAuth 2.0 Server (Part 06)</a></li><li><a href=/posts/oauthserver/05/>Implement an OAuth 2.0 Server (Part 05)</a></li><li><a href=/posts/oauthserver/04/>Implement an OAuth 2.0 Server (Part 04)</a></li><li><a href=/posts/oauthserver/03/>Implement an OAuth 2.0 Server (Part 03)</a></li><li><a href=/posts/oauthserver/02/>Implement an OAuth 2.0 Server (Part 02)</a></li><li><a href=/posts/oauthserver/01/>Implement an OAuth 2.0 Server (Part 01)</a></li></ul></div><div class=post__footer><span><a class=category href=/categories/security/>Security</a><a class=category href=/categories/identity/>Identity</a><a class=category href=/categories/authentication/>Authentication</a><a class=category href=/categories/authorization/>Authorization</a></span>
<span><a class=tag href=/tags/oauth2%2e0/>OAuth2.0</a><a class=tag href=/tags/openidconnect/>OpenIdConnect</a><a class=tag href=/tags/tutorial/>Tutorial</a><a class=tag href=/tags/csharp/>CSharp</a><a class=tag href=/tags/%2enet-core/>.NET Core</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
2023</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>